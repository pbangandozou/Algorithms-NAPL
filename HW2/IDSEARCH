1. Set the value of the variable "count" to 0. 

The number of the current candidate ID will be counted using this variable. 
2. Repeat this process for each element in the list. 
   a. Increase "count" if the element matches the current contender ID. If the current element and the current candidate match, we have discovered a second instance of the same ID. 
   b. If 'count' is greater than 0, decrease it in the alternative case. 
      - We "cancel out" one instance of the current candidate by decreasing "count" if the current element differs from the current candidate. 
c. If 'count' is 0, assign the current element's current candidate ID. 
      - We update the candidate to the current element when "count" hits zero, which indicates that we have "used up" all instances of the previous candidate. 
3. If the value of 'count' is larger than half the length of the list, the current candidate ID becomes the output ID. This phase determines if the current candidate ID consistently 
appears in the list more than 50% of the time. If the candidate has more occurrences than any other ID in the list, making it the majority element, the count is larger than half the size of the list. 
4. If not, there is no ID that appears strictly more than 50% of the time in the list if "count" is not larger than half the list's size. 

   - There is no majority ID if the 'count' did not grow by more than half the size of the list during the iteration. In other words, the algorithm yields this conclusion 
since no ID appears in the list precisely more than 50% of the time. 
If a majority ID is present in a list, this technique effectively locates it. It guarantees that it will correctly recognize an ID if there is a majority ID (an ID that appears more than 50% of the time). 

Example: [1, 1, 2, 1, 3, 1] 

Initialize count to 0. 
Start iterating through the list: 
a. First element: 1 
   - count is 0, so we set 1 as the current candidate, and count becomes 1. 
b. Second element: 1 
   - The current element matches the candidate, so we increment count to 2. 
c. Third element: 2 
   - The current element is different from the candidate (1), so we decrease count to 1. 
d. Fourth element: 1 
   - The current element is the same as the candidate, so we increment count to 2. 
e. Fifth element: 3 
   - The current element is different from the candidate (1), so we decrease count to 1. 
f. Sixth element: 1 
   - The current element is the same as the candidate, so we increment count to 2. 
After iterating through the entire list, we check the value of count. 
count is 2, and the size of the list is 6, which is greater than half of the list size (6/2 = 3). Since the count is greater than 3, we conclude that the output ID is 1. 
The algorithm works and we think it is correct because... 
- If one element appears more than half the time in a list, it's the only element with a count greater than half the list's size. 
- If there's another element with a similar count, it contradicts the idea of having only one majority element. 
- The algorithm tracks the count of the current candidate element. If its count exceeds half the list size, it's the output ID. 
 	- If no candidate has a count greater than half the list size, there's no ID appearing strictly more than 50% of the time in the list. 
